import { createHash } from 'node:crypto';

import type { CustomOctokit } from './octokit';
import type {
  ExternalFailure,
  FailedJob,
  GeminiReviewResponse,
  ReviewComment,
} from './schema';
import { confidenceBadge } from './util';

const AI_DISCLAIMER =
  '> [!IMPORTANT]\\n> This analysis was generated by AI and may not be fully accurate. Please review the suggestions critically before applying any changes.';

export class Review {
  static readonly FINGERPRINT_MARKER = 'review-buddy-fingerprint';

  static computeFingerprint(
    headSha: string,
    failedJobs: FailedJob[],
    externalFailures: ExternalFailure[]
  ): string {
    const parts = [
      headSha,
      ...failedJobs.map(j => j.name).sort(),
      ...externalFailures.map(f => `${f.source}:${f.name}`).sort(),
    ];
    return createHash('sha256')
      .update(parts.join('\n'))
      .digest('hex')
      .slice(0, 16);
  }

  static async findExistingFingerprint(
    octokit: CustomOctokit,
    owner: string,
    repo: string,
    pullNumber: number
  ): Promise<string | null> {
    let page = 1;

    while (true) {
      const response = await octokit.request(
        'GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews',
        { owner, repo, pull_number: pullNumber, per_page: 100, page }
      );

      for (let i = response.data.length - 1; i >= 0; i--) {
        const review = response.data[i];
        const match = review.body?.match(
          new RegExp(`<!-- ${Review.FINGERPRINT_MARKER}:([a-f0-9]+) -->`)
        );
        if (match?.[1]) {
          return match[1];
        }
      }

      if (response.data.length < 100) break;
      page++;
    }

    return null;
  }

  static formatBody(
    analysis: GeminiReviewResponse,
    fingerprint: string
  ): string {
    const badge = confidenceBadge(analysis.confidence);
    return [
      `## Review Buddy - CI Failure Analysis`,
      `<!-- ${Review.FINGERPRINT_MARKER}:${fingerprint} -->`,
      '',
      AI_DISCLAIMER,
      '',
      `${badge} **Confidence:** ${analysis.confidence}`,
      '',
      analysis.summary,
    ].join('\n');
  }

  static formatStatus(
    analysis?: GeminiReviewResponse | null,
    reviewId?: number
  ): string {
    if (!analysis) {
      return JSON.stringify(
        '### Review Buddy\\n\\n:green_circle: No CI failures detected'
      );
    }

    const badge = confidenceBadge(analysis.confidence);
    const lines: string[] = ['### Review Buddy', '', AI_DISCLAIMER, ''];

    if (reviewId !== undefined) {
      lines.push(
        `${badge} ${analysis.comments.length} CI failure comment(s) posted (confidence: ${analysis.confidence})`
      );
    } else if (analysis.comments.length > 0) {
      lines.push(
        `${badge} ${analysis.comments.length} CI failure(s) analyzed but review could not be posted (confidence: ${analysis.confidence})`
      );
    } else {
      lines.push(
        `${badge} CI failures analyzed - no code changes identified as the cause (confidence: ${analysis.confidence})`
      );
    }

    lines.push('');
    lines.push(analysis.summary);

    return JSON.stringify(lines.join('\\n'));
  }

  static formatSkippedStatus(): string {
    return JSON.stringify(
      '### Review Buddy\\n\\n:white_check_mark: CI failures already reviewed - see existing review comments'
    );
  }

  static formatErrorStatus(): string {
    return JSON.stringify(
      '### Review Buddy\\n\\n:warning: AI analysis of CI failures could not be completed'
    );
  }

  static async post(
    octokit: CustomOctokit,
    owner: string,
    repo: string,
    pullNumber: number,
    commitId: string,
    body: string,
    comments: ReviewComment[],
    event: 'COMMENT' | 'REQUEST_CHANGES'
  ): Promise<number> {
    const apiComments = comments.map(comment => ({
      path: comment.path,
      line: comment.line,
      side: comment.side as 'RIGHT',
      body: comment.body,
    }));

    const response = await octokit.request(
      'POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews',
      {
        owner,
        repo,
        pull_number: pullNumber,
        commit_id: commitId,
        body,
        event,
        comments: apiComments,
      }
    );

    return response.data.id;
  }
}
